微服务 就是吧一个项目所有模块拆分，让这些模块只是仅仅数据上的交互
 比如 User--->Power  他们2个是独立的模块，
 分布式 就是将大系统划分为多个模块 然后部署在不同的机器上，
 目标i不一样  微服务只是让各个模块进行拆分
  而分布式主要就是说一台机器承受不了 部署在多台机器上
  //Springcloud 基于Springboot
  
  Erueka有2个组件 一个Erueka 服务端 一个Erueka客户端 
  
			Erureka服务端
  寻找服务与注册服务
  UserClient			PowerClient
  每一个客户端都可以寻找服务和注册服务  也就是说 客户端可以吧自己注册到Erueka上
  也就是说 父pom中，直接用dependence的依赖 子项目的pom无需再引用 直接无条件继承 而父pom中用在dependenceManagement里的dependence，子项目想要继承就必须在自己的pom中再声明一次 但是不需要写版本号默认继承父pom中的版本，如果指定了版本号就是用自己的版本
  dependencyManagement-->版本问题   <-->    <scope>import</scope> 1.版本的管理 2， 类似与Parent的效果 3.导入jar 类似于Parent
  <dependencyManagement>
  <scope>
  Erueka 集群----->做到Erueka的高可用
  Client需要配置3个地址
  分布式Cap理论
  C  一致性
  A   可用性
  P  分区容错性
    2个服务器集群 一个在本地 另一个在外地
	区间通信可能失败
	S1   S2        S1向S2发送一条消息 可能失败  比如说网络延迟
   
Client向S1发送一个写操作 将Vo改成V1 ，接下来用户读错做得到V1,这叫一致性问题是用户可能会向S2发起读操作
问题是用户可能会向S2发起读操作:此时读取的值可能是Vo
此时S1和S2的值就不同   就不满足一致性
为了让S1和S2一致性，我们需要 在给S1执行写操作的时候，让S1给S2发条消息  改变V1的值
  
这样的话C --->S2 发起就会得到改变后的值
所以说啊 要保证一致性的话只能等待S2吧数据改了之后  
保证可用性 的话就能随时去取  只不过拿到的值不是最新的
ZOOK  一致性
 因为当Master 节点因为网络故障时与其他节点失去联系，剩余的节点会进行重新leader选举
在选举中间整个集群是不可用的，这就导致在选举期间整个注册服务是瘫痪的 


但是Eureka各个节点是平等额，几个节点Down掉后没有关系 剩余的节点会依然进行注册服务
Erueka客户端在向某个Erueka注册发现连接失败 ，会连接其他的， 也就是说只要有一个Erueka 存在就能注册上[高可用]
只不过查到的消息不是最新的  
////////////////////
2.